From bacec5d54717281cec6cd27599e314b93b1f7adb Mon Sep 17 00:00:00 2001
From: Sun Haiyong <sunhaiyong@zdbr.net>
Date: Mon, 17 Jun 2024 08:06:21 +0000
Subject: [PATCH 01/11] Chromium 126 third_party crashpad add loongarch64
 support.

from https://github.com/loongson/chromium/tree/loongarch-patches/chromium120/new-world reference.
---
 .../crashpad/compat/linux/sys/ptrace.h        |  4 +
 .../crashpad/crashpad/compat/non_win/winnt.h  |  1 +
 .../crashpad/minidump/minidump_context.h      | 30 +++++++
 .../minidump/minidump_context_writer.cc       | 44 ++++++++++
 .../minidump/minidump_context_writer.h        | 38 +++++++++
 .../minidump/minidump_context_writer_test.cc  | 15 ++++
 .../crashpad/minidump/minidump_extensions.h   |  1 +
 .../minidump/minidump_misc_info_writer.cc     |  2 +
 .../test/minidump_context_test_util.cc        | 46 +++++++++++
 .../test/minidump_context_test_util.h         |  5 ++
 .../crashpad/crashpad/snapshot/BUILD.gn       |  6 +-
 .../crashpad/snapshot/capture_memory.cc       |  4 +
 .../crashpad/snapshot/cpu_architecture.h      |  3 +
 .../crashpad/crashpad/snapshot/cpu_context.cc |  5 ++
 .../crashpad/crashpad/snapshot/cpu_context.h  | 10 +++
 .../crashpad/snapshot/elf/elf_image_reader.cc | 14 ++++
 .../snapshot/elf/elf_symbol_table_reader.cc   | 27 ++++--
 .../snapshot/linux/cpu_context_linux.cc       | 24 ++++++
 .../snapshot/linux/cpu_context_linux.h        | 24 ++++++
 .../linux/exception_snapshot_linux.cc         | 74 ++++++++++++++++-
 .../snapshot/linux/exception_snapshot_linux.h |  2 +
 .../linux/exception_snapshot_linux_test.cc    | 42 ++++++++++
 .../snapshot/linux/process_reader_linux.cc    |  2 +
 .../crashpad/snapshot/linux/signal_context.h  | 38 +++++++++
 .../snapshot/linux/system_snapshot_linux.cc   | 11 +++
 .../crashpad/snapshot/linux/test_modules.cc   |  4 +
 .../snapshot/linux/thread_snapshot_linux.cc   |  6 ++
 .../snapshot/linux/thread_snapshot_linux.h    |  2 +
 .../minidump/minidump_context_converter.cc    | 22 +++++
 .../minidump/system_snapshot_minidump.cc      |  2 +
 .../snapshot/test/test_cpu_context.cc         | 20 +++++
 .../crashpad/snapshot/test/test_cpu_context.h |  1 +
 .../crashpad/crashpad/test/linux/get_tls.cc   |  3 +
 .../crashpad/test/multiprocess_posix.cc       |  3 +-
 .../crashpad/crashpad/util/linux/ptracer.cc   | 48 +++++++++++
 .../crashpad/util/linux/thread_info.h         | 21 ++++-
 .../crashpad/util/misc/capture_context.h      |  1 +
 .../util/misc/capture_context_linux.S         | 82 ++++++++++++++++++-
 .../util/misc/capture_context_test.cc         |  2 +-
 .../misc/capture_context_test_util_linux.cc   |  6 ++
 .../util/net/http_transport_libcurl.cc        |  2 +
 41 files changed, 678 insertions(+), 19 deletions(-)

diff --git a/third_party/crashpad/crashpad/compat/linux/sys/ptrace.h b/third_party/crashpad/crashpad/compat/linux/sys/ptrace.h
index 604a46ab06..068a7c9799 100644
--- a/third_party/crashpad/crashpad/compat/linux/sys/ptrace.h
+++ b/third_party/crashpad/crashpad/compat/linux/sys/ptrace.h
@@ -38,6 +38,10 @@ static constexpr __ptrace_request PTRACE_GET_THREAD_AREA =
 static constexpr __ptrace_request PTRACE_GET_THREAD_AREA_3264 =
     static_cast<__ptrace_request>(0xc4);
 #define PTRACE_GET_THREAD_AREA_3264 PTRACE_GET_THREAD_AREA_3264
+#elif defined(__loongarch_lp64)
+static constexpr __ptrace_request PTRACE_GET_THREAD_AREA =
+    static_cast<__ptrace_request>(25);
+#define PTRACE_GET_THREAD_AREA PTRACE_GET_THREAD_AREA
 #endif
 #endif  // !PTRACE_GET_THREAD_AREA && !PT_GET_THREAD_AREA && defined(__GLIBC__)
 
diff --git a/third_party/crashpad/crashpad/compat/non_win/winnt.h b/third_party/crashpad/crashpad/compat/non_win/winnt.h
index 5fd78b0d8e..57a972000b 100644
--- a/third_party/crashpad/crashpad/compat/non_win/winnt.h
+++ b/third_party/crashpad/crashpad/compat/non_win/winnt.h
@@ -67,6 +67,7 @@
 #define PROCESSOR_ARCHITECTURE_NEUTRAL 11
 #define PROCESSOR_ARCHITECTURE_ARM64 12
 #define PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64 13
+#define PROCESSOR_ARCHITECTURE_LOONGARCH64 14
 #define PROCESSOR_ARCHITECTURE_UNKNOWN 0xffff
 //! \}
 
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context.h b/third_party/crashpad/crashpad/minidump/minidump_context.h
index 12413de02b..bf60cf281d 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context.h
+++ b/third_party/crashpad/crashpad/minidump/minidump_context.h
@@ -687,6 +687,36 @@ struct MinidumpContextRISCV64 {
   uint32_t fcsr;
 };
 
+//! \brief LOONGARCH64-specifc flags for MinidumpContextLOONGARCH64::context_flags.
+//! Based on minidump_cpu_loongarch64.h from breakpad
+enum MinidumpContextLOONGARCH64Flags : uint32_t {
+  //! \brief Identifies the context structure as LOONGARCH64.
+  kMinidumpContextLOONGARCH64 = 0x00800000,
+
+  //! \brief Indicates the validity of integer registers.
+  //!
+  //! Registers `0`-`31`, `epc` are valid.
+  kMinidumpContextLOONGARCH64Integer = kMinidumpContextLOONGARCH64 | 0x00000002,
+
+  //! \brief Indicates the validity of floating point registers.
+  //!
+  //! Floating point registers `0`-`31`, `fpcsr` and `fir` are valid
+  kMinidumpContextLOONGARCH64FloatingPoint = kMinidumpContextLOONGARCH64 | 0x00000004,
+
+  //! \brief Indicates the validity of all registers.
+  kMinidumpContextLOONGARCH64All = kMinidumpContextLOONGARCH64Integer |
+                              kMinidumpContextLOONGARCH64FloatingPoint,
+};
+
+//! \brief A LOONGARCH64 CPU context (register state) carried in a minidump file.
+struct MinidumpContextLOONGARCH64 {
+  uint32_t context_flags;
+  uint64_t sc_pc;
+  uint64_t sc_regs[32];
+  uint64_t fregs[32];
+  uint64_t fcc;
+  uint32_t fcsr;
+};
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_H_
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
index 4a6130b63e..21c29382c1 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
@@ -110,6 +110,13 @@ MinidumpContextWriter::CreateFromSnapshot(const CPUContext* context_snapshot) {
       break;
     }
 
+    case kCPUArchitectureLOONGARCH64: {
+      context = std::make_unique<MinidumpContextLOONGARCH64Writer>();
+      reinterpret_cast<MinidumpContextLOONGARCH64Writer*>(context.get())
+          ->InitializeFromSnapshot(context_snapshot->loongarch64);
+      break;
+    }
+
     default: {
       LOG(ERROR) << "unknown context architecture "
                  << context_snapshot->architecture;
@@ -606,4 +613,41 @@ size_t MinidumpContextRISCV64Writer::ContextSize() const {
   return sizeof(context_);
 }
 
+MinidumpContextLOONGARCH64Writer::MinidumpContextLOONGARCH64Writer()
+    : MinidumpContextWriter(), context_() {
+  context_.context_flags = kMinidumpContextLOONGARCH64;
+}
+
+MinidumpContextLOONGARCH64Writer::~MinidumpContextLOONGARCH64Writer() = default;
+
+void MinidumpContextLOONGARCH64Writer::InitializeFromSnapshot(
+    const CPUContextLOONGARCH64* context_snapshot) {
+  DCHECK_EQ(state(), kStateMutable);
+  DCHECK_EQ(context_.context_flags, kMinidumpContextLOONGARCH64);
+
+  context_.context_flags = kMinidumpContextLOONGARCH64All;
+
+  static_assert(sizeof(context_.sc_regs) == sizeof(context_snapshot->sc_regs),
+                "GPRs size mismatch");
+  memcpy(context_.sc_regs, context_snapshot->sc_regs, sizeof(context_.sc_regs));
+  context_.sc_pc = context_snapshot->sc_pc;
+
+  static_assert(sizeof(context_.fregs) == sizeof(context_snapshot->fregs),
+                "FPU size mismatch");
+  memcpy(context_.fregs, context_snapshot->fregs, sizeof(context_.fregs));
+  context_.fcsr = context_snapshot->fcsr;
+  context_.fcc = context_snapshot->fcc;
+}
+
+bool MinidumpContextLOONGARCH64Writer::WriteObject(
+    FileWriterInterface* file_writer) {
+  DCHECK_EQ(state(), kStateWritable);
+  return file_writer->Write(&context_, sizeof(context_));
+}
+
+size_t MinidumpContextLOONGARCH64Writer::ContextSize() const {
+  DCHECK_GE(state(), kStateFrozen);
+  return sizeof(context_);
+}
+
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context_writer.h b/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
index 8e39c6692f..85ca7ffd2e 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
+++ b/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
@@ -413,6 +413,44 @@ class MinidumpContextRISCV64Writer final : public MinidumpContextWriter {
   MinidumpContextRISCV64 context_;
 };
 
+//! \brief The writer for a MinidumpContextLOONGARCH64 structure in a minidump file.
+class MinidumpContextLOONGARCH64Writer final : public MinidumpContextWriter {
+ public:
+  MinidumpContextLOONGARCH64Writer();
+  ~MinidumpContextLOONGARCH64Writer() override;
+
+  //! \brief Initializes the MinidumpContextLOONGARCH based on \a context_snapshot.
+  //!
+  //! \param[in] context_snapshot The context snapshot to use as source data.
+  //!
+  //! \note Valid in #kStateMutable. No mutation of context() may be done before
+  //!     calling this method, and it is not normally necessary to alter
+  //!     context() after calling this method.
+  void InitializeFromSnapshot(const CPUContextLOONGARCH64* context_snapshot);
+
+  //! \brief Returns a pointer to the context structure that this object will
+  //!     write.
+  //!
+  //! \attention This returns a non-`const` pointer to this object’s private
+  //!     data so that a caller can populate the context structure directly.
+  //!     This is done because providing setter interfaces to each field in the
+  //!     context structure would be unwieldy and cumbersome. Care must be taken
+  //!     to populate the context structure correctly. The context structure
+  //!     must only be modified while this object is in the #kStateMutable
+  //!     state.
+  MinidumpContextLOONGARCH64* context() { return &context_; }
+
+ protected:
+  // MinidumpWritable:
+  bool WriteObject(FileWriterInterface* file_writer) override;
+
+  // MinidumpContextWriter:
+  size_t ContextSize() const override;
+
+ private:
+  MinidumpContextLOONGARCH64 context_;
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_WRITER_H_
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc b/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
index 9eebe81b29..a11e3f0940 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
@@ -328,6 +328,21 @@ TYPED_TEST(MinidumpContextWriter, RISCV64_FromSnapshot) {
                    TypeParam>(context, ExpectMinidumpContextRISCV64, kSeed);
 }
 
+TYPED_TEST(MinidumpContextWriter, LOONGARCH64_Zeros) {
+  EmptyContextTest<MinidumpContextLOONGARCH64Writer, MinidumpContextLOONGARCH64, TypeParam>(
+      ExpectMinidumpContextLOONGARCH64);
+}
+
+TYPED_TEST(MinidumpContextWriter, LOONGARCH64_FromSnapshot) {
+  constexpr uint32_t kSeed = 64;
+  CPUContextLOONGARCH64 context_loongarch64;
+  CPUContext context;
+  context.loongarch64 = &context_loongarch64;
+  InitializeCPUContextLOONGARCH64(&context, kSeed);
+  FromSnapshotTest<MinidumpContextLOONGARCH64Writer, MinidumpContextLOONGARCH64, TypeParam>(
+      context, ExpectMinidumpContextLOONGARCH64, kSeed);
+}
+
 }  // namespace
 }  // namespace test
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/minidump/minidump_extensions.h b/third_party/crashpad/crashpad/minidump/minidump_extensions.h
index a5f442bf5e..d8904ab545 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_extensions.h
+++ b/third_party/crashpad/crashpad/minidump/minidump_extensions.h
@@ -154,6 +154,7 @@ enum MinidumpCPUArchitecture : uint16_t {
   kMinidumpCPUArchitectureX86 = PROCESSOR_ARCHITECTURE_INTEL,
 
   kMinidumpCPUArchitectureMIPS = PROCESSOR_ARCHITECTURE_MIPS,
+  kMinidumpCPUArchitectureLOONGARCH64 = PROCESSOR_ARCHITECTURE_LOONGARCH64,
   kMinidumpCPUArchitectureAlpha = PROCESSOR_ARCHITECTURE_ALPHA,
 
   //! \brief 32-bit PowerPC.
diff --git a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
index 1abb46c318..e0779980d0 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
@@ -177,6 +177,8 @@ std::string MinidumpMiscInfoDebugBuildString() {
   static constexpr char kCPU[] = "mips64";
 #elif defined(ARCH_CPU_RISCV64)
   static constexpr char kCPU[] = "riscv64";
+#elif defined(ARCH_CPU_LOONGARCH64)
+  static constexpr char kCPU[] = "loongarch64";
 #else
 #error define kCPU for this CPU
 #endif
diff --git a/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.cc b/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.cc
index b40558cf28..06c0a0c3c1 100644
--- a/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.cc
+++ b/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.cc
@@ -297,6 +297,31 @@ void InitializeMinidumpContextRISCV64(MinidumpContextRISCV64* context,
   context->fcsr = value++;
 }
 
+void InitializeMinidumpContextLOONGARCH64(MinidumpContextLOONGARCH64* context,
+                                     uint32_t seed) {
+  if (seed == 0) {
+    memset(context, 0, sizeof(*context));
+    context->context_flags = kMinidumpContextLOONGARCH64;
+    return;
+  }
+
+  context->context_flags = kMinidumpContextLOONGARCH64All;
+
+  uint64_t value = seed;
+
+  for (size_t index = 0; index < std::size(context->sc_regs); ++index) {
+    context->sc_regs[index] = value++;
+  }
+
+  context->sc_pc = value++;
+
+  for (size_t index = 0; index < std::size(context->fregs); ++index) {
+    context->fregs[index] = static_cast<double>(value++);
+  }
+  context->fcsr = value++;
+  context->fcc = value++;
+}
+
 namespace {
 
 // Using Google Test assertions, compares |expected| to |observed|. This is
@@ -645,5 +670,26 @@ void ExpectMinidumpContextRISCV64(uint32_t expect_seed,
   EXPECT_EQ(observed->fcsr, expected.fcsr);
 }
 
+void ExpectMinidumpContextLOONGARCH64(uint32_t expect_seed,
+                                 const MinidumpContextLOONGARCH64* observed,
+                                 bool snapshot) {
+  MinidumpContextLOONGARCH64 expected;
+  InitializeMinidumpContextLOONGARCH64(&expected, expect_seed);
+
+  EXPECT_EQ(observed->context_flags, expected.context_flags);
+
+  for (size_t index = 0; index < std::size(expected.sc_regs); ++index) {
+    EXPECT_EQ(observed->sc_regs[index], expected.sc_regs[index]);
+  }
+
+  EXPECT_EQ(observed->sc_pc, expected.sc_pc);
+
+  for (size_t index = 0; index < std::size(expected.fregs); ++index) {
+    EXPECT_EQ(observed->fregs[index], expected.fregs[index]);
+  }
+  EXPECT_EQ(observed->fcsr, expected.fcsr);
+  EXPECT_EQ(observed->fcc, expected.fcc);
+}
+
 }  // namespace test
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.h b/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.h
index 4ce5c1e1c3..cadb24ee01 100644
--- a/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.h
+++ b/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.h
@@ -49,6 +49,8 @@ void InitializeMinidumpContextMIPS64(MinidumpContextMIPS* context,
                                      uint32_t seed);
 void InitializeMinidumpContextRISCV64(MinidumpContextRISCV64* context,
                                       uint32_t seed);
+void InitializeMinidumpContextLOONGARCH64(MinidumpContextLOONGARCH64* context,
+                                          uint32_t seed);
 //! \}
 
 //! \brief Verifies, via Google Test assertions, that a context structure
@@ -90,6 +92,9 @@ void ExpectMinidumpContextMIPS64(uint32_t expect_seed,
 void ExpectMinidumpContextRISCV64(uint32_t expect_seed,
                                   const MinidumpContextRISCV64* observed,
                                   bool snapshot);
+void ExpectMinidumpContextLOONGARCH64(uint32_t expect_seed,
+                                      const MinidumpContextLOONGARCH64* observed,
+                                      bool snapshot);
 //! \}
 
 }  // namespace test
diff --git a/third_party/crashpad/crashpad/snapshot/BUILD.gn b/third_party/crashpad/crashpad/snapshot/BUILD.gn
index 2ae944c3e8..69eda6a08a 100644
--- a/third_party/crashpad/crashpad/snapshot/BUILD.gn
+++ b/third_party/crashpad/crashpad/snapshot/BUILD.gn
@@ -468,7 +468,8 @@ source_set("snapshot_test") {
   }
 
   if ((crashpad_is_linux || crashpad_is_android || crashpad_is_fuchsia) &&
-      target_cpu != "mipsel" && target_cpu != "mips64el") {
+      target_cpu != "mipsel" && target_cpu != "mips64el" &&
+      target_cpu != "loongarch64") {
     data_deps += [ ":crashpad_snapshot_test_both_dt_hash_styles" ]
   }
 
@@ -554,7 +555,8 @@ crashpad_loadable_module("crashpad_snapshot_test_module_small") {
 }
 
 if ((crashpad_is_linux || crashpad_is_android || crashpad_is_fuchsia) &&
-    target_cpu != "mipsel" && target_cpu != "mips64el") {
+    target_cpu != "mipsel" && target_cpu != "mips64el" &&
+      target_cpu != "loongarch64") {
   crashpad_loadable_module("crashpad_snapshot_test_both_dt_hash_styles") {
     testonly = true
     sources = [ "hash_types_test.cc" ]
diff --git a/third_party/crashpad/crashpad/snapshot/capture_memory.cc b/third_party/crashpad/crashpad/snapshot/capture_memory.cc
index f2ff5d74bb..40cc319c75 100644
--- a/third_party/crashpad/crashpad/snapshot/capture_memory.cc
+++ b/third_party/crashpad/crashpad/snapshot/capture_memory.cc
@@ -123,6 +123,10 @@ void CaptureMemory::PointedToByContext(const CPUContext& context,
   for (size_t i = 0; i < std::size(context.riscv64->regs); ++i) {
     MaybeCaptureMemoryAround(delegate, context.riscv64->regs[i]);
   }
+#elif defined(ARCH_CPU_LOONGARCH64)
+  for (size_t i = 0; i < std::size(context.loongarch64->sc_regs); ++i) {
+    MaybeCaptureMemoryAround(delegate, context.loongarch64->sc_regs[i]);
+  }
 #else
 #error Port.
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_architecture.h b/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
index 26d45f8412..702a2a7d1b 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
+++ b/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
@@ -47,6 +47,9 @@ enum CPUArchitecture {
 
   //! \brief 64-bit RISC-V.
   kCPUArchitectureRISCV64,
+
+  //! \brief 64-bit LOONGARCH.
+  kCPUArchitectureLOONGARCH64,
 };
 
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_context.cc b/third_party/crashpad/crashpad/snapshot/cpu_context.cc
index 492a0f7f91..9356b4df8b 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_context.cc
+++ b/third_party/crashpad/crashpad/snapshot/cpu_context.cc
@@ -173,6 +173,8 @@ uint64_t CPUContext::InstructionPointer() const {
       return arm64->pc;
     case kCPUArchitectureRISCV64:
       return riscv64->pc;
+    case kCPUArchitectureLOONGARCH64:
+      return loongarch64->sc_pc;
     default:
       NOTREACHED();
       return ~0ull;
@@ -191,6 +193,8 @@ uint64_t CPUContext::StackPointer() const {
       return arm64->sp;
     case kCPUArchitectureRISCV64:
       return riscv64->regs[1];
+    case kCPUArchitectureLOONGARCH64:
+      return loongarch64->sc_regs[3];
     default:
       NOTREACHED();
       return ~0ull;
@@ -232,6 +236,7 @@ bool CPUContext::Is64Bit() const {
     case kCPUArchitectureARM64:
     case kCPUArchitectureMIPS64EL:
     case kCPUArchitectureRISCV64:
+    case kCPUArchitectureLOONGARCH64:
       return true;
     case kCPUArchitectureX86:
     case kCPUArchitectureARM:
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_context.h b/third_party/crashpad/crashpad/snapshot/cpu_context.h
index c3640c328c..87334c21d2 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_context.h
+++ b/third_party/crashpad/crashpad/snapshot/cpu_context.h
@@ -371,6 +371,15 @@ struct CPUContextRISCV64 {
   uint32_t fcsr;
 };
 
+//! \brief A context structure carrying LOONGARCH64 CPU state.
+struct CPUContextLOONGARCH64 {
+  uint64_t sc_pc;
+  uint64_t sc_regs[32];
+  uint64_t fregs[32];
+  uint64_t fcc;
+  uint32_t fcsr;
+};
+
 //! \brief A context structure capable of carrying the context of any supported
 //!     CPU architecture.
 struct CPUContext {
@@ -412,6 +421,7 @@ struct CPUContext {
     CPUContextMIPS* mipsel;
     CPUContextMIPS64* mips64;
     CPUContextRISCV64* riscv64;
+    CPUContextLOONGARCH64* loongarch64;
   };
 };
 
diff --git a/third_party/crashpad/crashpad/snapshot/elf/elf_image_reader.cc b/third_party/crashpad/crashpad/snapshot/elf/elf_image_reader.cc
index b0340e5fbd..b77d595f81 100644
--- a/third_party/crashpad/crashpad/snapshot/elf/elf_image_reader.cc
+++ b/third_party/crashpad/crashpad/snapshot/elf/elf_image_reader.cc
@@ -594,6 +594,7 @@ bool ElfImageReader::ReadDynamicStringTableAtOffset(VMSize offset,
     return false;
   }
 
+#if !defined(__loongarch_lp64)
   // GNU ld.so doesn't adjust the vdso's dynamic array entries by the load bias.
   // If the address is too small to point into the loaded module range and is
   // small enough to be an offset from the base of the module, adjust it now.
@@ -601,6 +602,11 @@ bool ElfImageReader::ReadDynamicStringTableAtOffset(VMSize offset,
       string_table_address < memory_.Size()) {
     string_table_address += GetLoadBias();
   }
+#else
+  // LoongArch ABI specifies that the dynamic section has to be read-only.
+  // See glibc: sysdeps/loongarch/ldsodefs.h
+  string_table_address += GetLoadBias();
+#endif
 
   if (!memory_.ReadCStringSizeLimited(
           string_table_address + offset, string_table_size - offset, string)) {
@@ -758,6 +764,10 @@ bool ElfImageReader::GetNumberOfSymbolEntriesFromDtHash(
     return false;
   }
 
+#if defined(__loongarch_lp64)
+  dt_hash_address += GetLoadBias();
+#endif
+
   struct {
     uint32_t nbucket;
     uint32_t nchain;
@@ -783,6 +793,10 @@ bool ElfImageReader::GetNumberOfSymbolEntriesFromDtGnuHash(
     return false;
   }
 
+#if defined(__loongarch_lp64)
+  dt_gnu_hash_address += GetLoadBias();
+#endif
+
   // See https://flapenguin.me/2017/05/10/elf-lookup-dt-gnu-hash/ and
   // https://sourceware.org/ml/binutils/2006-10/msg00377.html.
   struct {
diff --git a/third_party/crashpad/crashpad/snapshot/elf/elf_symbol_table_reader.cc b/third_party/crashpad/crashpad/snapshot/elf/elf_symbol_table_reader.cc
index 4c59d74599..a082e9a86c 100644
--- a/third_party/crashpad/crashpad/snapshot/elf/elf_symbol_table_reader.cc
+++ b/third_party/crashpad/crashpad/snapshot/elf/elf_symbol_table_reader.cc
@@ -72,16 +72,25 @@ bool ElfSymbolTableReader::ScanSymbolTable(const std::string& name,
   SymEnt entry;
   std::string string;
   size_t i = 0;
+  const char vdso_prefix[] = "__vdso_";
+
+#if defined(__loongarch_lp64)
+  address += elf_reader_->GetLoadBias();
+#endif
+
   while (i < num_entries_ && memory_->Read(address, sizeof(entry), &entry)) {
-    if (elf_reader_->ReadDynamicStringTableAtOffset(entry.st_name, &string) &&
-        string == name) {
-      info_out->address = entry.st_value;
-      info_out->size = entry.st_size;
-      info_out->shndx = entry.st_shndx;
-      info_out->binding = GetBinding(entry);
-      info_out->type = GetType(entry);
-      info_out->visibility = GetVisibility(entry);
-      return true;
+    if (elf_reader_->ReadDynamicStringTableAtOffset(entry.st_name, &string)) {
+      if (string.find(vdso_prefix) == 0)
+        string.erase(0, sizeof(vdso_prefix) - 1);
+      if (string == name) {
+        info_out->address = entry.st_value;
+        info_out->size = entry.st_size;
+        info_out->shndx = entry.st_shndx;
+        info_out->binding = GetBinding(entry);
+        info_out->type = GetType(entry);
+        info_out->visibility = GetVisibility(entry);
+        return true;
+      }
     }
     // TODO(scottmg): This should respect DT_SYMENT if present.
     address += sizeof(entry);
diff --git a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc
index 6c4cb3ebce..fb1ca6c96a 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc
@@ -280,7 +280,31 @@ void InitializeCPUContextRISCV64(const ThreadContext::t64_t& thread_context,
   memcpy(context->fpregs, float_context.fpregs, sizeof(context->fpregs));
   context->fcsr = float_context.fcsr;
 }
+#elif defined(ARCH_CPU_LOONGARCH64)
+void InitializeCPUContextLOONGARCH64(const ThreadContext::t64_t& thread_context,
+                               const FloatContext::f64_t& float_context,
+                               CPUContextLOONGARCH64* context) {
+  InitializeCPUContextLOONGARCH64_NoFloatingPoint(thread_context, context);
+
+  static_assert(sizeof(context->fregs) == sizeof(float_context.fregs),
+                "fpu context size mismatch");
+  memcpy(context->fregs, float_context.fregs, sizeof(context->fregs));
+  context->fcc = float_context.fcc;
+  context->fcsr = float_context.fcsr;
+}
 
+void InitializeCPUContextLOONGARCH64_NoFloatingPoint(
+    const ThreadContext::t64_t& thread_context,
+    CPUContextLOONGARCH64* context) {
+  static_assert(sizeof(context->sc_regs) == sizeof(thread_context.regs),
+                "gpr context size mismtach");
+  memcpy(context->sc_regs, thread_context.regs, sizeof(context->sc_regs));
+  context->sc_pc = thread_context.csr_era;
+
+  memset(&context->fregs, 0, sizeof(context->fregs));
+  context->fcc = 0;
+  context->fcsr = 0;
+}
 #endif  // ARCH_CPU_X86_FAMILY
 
 }  // namespace internal
diff --git a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
index 507d1b44dd..65c29d4471 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
@@ -188,6 +188,30 @@ void InitializeCPUContextRISCV64(const ThreadContext::t64_t& thread_context,
 
 #endif  // ARCH_CPU_RISCV64 || DOXYGEN
 
+#if defined(ARCH_CPU_LOONGARCH64) || DOXYGEN
+//! \brief Initializes a CPUContextARM64 structure from native context
+//!     structures on Linux.
+//!
+//! \param[in] thread_context The native thread context.
+//! \param[in] float_context The native float context.
+//! \param[out] context The CPUContextARM64 structure to initialize.
+void InitializeCPUContextLOONGARCH64(const ThreadContext::t64_t& thread_context,
+                               const FloatContext::f64_t& float_context,
+                               CPUContextLOONGARCH64* context);
+
+//! \brief Initializes GPR state in a CPUContextARM64 from a native context
+//!     structure on Linux.
+//!
+//! Floating point state is initialized to zero.
+//!
+//! \param[in] thread_context The native thread context.
+//! \param[out] context The CPUContextARM64 structure to initialize.
+void InitializeCPUContextLOONGARCH64_NoFloatingPoint(
+    const ThreadContext::t64_t& thread_context,
+    CPUContextLOONGARCH64* context);
+
+#endif  // ARCH_CPU_LOONGARCH64 || DOXYGEN
+
 }  // namespace internal
 }  // namespace crashpad
 
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
index 677afdaa77..62b126b653 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
@@ -367,6 +367,78 @@ bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
   return internal::ReadContext(reader, context_address, context_.riscv64);
 }
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+
+template <typename Traits>
+static bool ReadContext(ProcessReaderLinux* reader,
+                        LinuxVMAddress context_address,
+                        typename Traits::CPUContext* dest_context) {
+  const ProcessMemory* memory = reader->Memory();
+
+  LinuxVMAddress gregs_address = context_address +
+                                 offsetof(UContext<Traits>, mcontext) +
+                                 offsetof(typename Traits::MContext, gregs);
+
+  typename Traits::SignalThreadContext thread_context;
+  if (!memory->Read(gregs_address, sizeof(thread_context), &thread_context)) {
+    LOG(ERROR) << "Couldn't read gregs";
+    return false;
+  }
+
+  LinuxVMAddress reserved_address =
+      context_address + offsetof(typename Traits::MContext, sc_extcontext);
+  if ((reserved_address & 15) != 0) {
+    LOG(ERROR) << "invalid alignment 0x" << std::hex << reserved_address;
+    return false;
+  }
+
+  constexpr VMSize kMaxContextSpace = 4096;
+
+  ProcessMemoryRange range;
+  if (!range.Initialize(memory, true, reserved_address, kMaxContextSpace)) {
+    return false;
+  }
+
+  do {
+    SCTXInfo sctx;
+    if (!range.Read(reserved_address, sizeof(sctx), &sctx)) {
+      LOG(ERROR) << "missing context sctx";
+      return false;
+    }
+
+    switch (sctx.magic) {
+      case FPU_CTX_MAGIC:
+        FPUContext fpu;
+        if (!range.Read(reserved_address, sizeof(fpu), &fpu)) {
+          LOG(ERROR) << "Couldn't read fpu " << sctx.size;
+          return false;
+        }
+        return true;
+      case 0:
+        LOG(WARNING) << "fpu not found";
+        return true;
+
+      default:
+        LOG(ERROR) << "invalid magic number 0x" << std::hex << sctx.magic;
+        return false;
+    }
+  } while (true);
+
+  return true;
+
+}
+
+template <>
+bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
+    ProcessReaderLinux* reader,
+    LinuxVMAddress context_address) {
+  context_.architecture = kCPUArchitectureLOONGARCH64;
+  context_.loongarch64 = &context_union_.loongarch64;
+
+  return internal::ReadContext<ContextTraits64>(
+      reader, context_address, context_.loongarch64);
+}
+
 #endif  // ARCH_CPU_X86_FAMILY
 
 bool ExceptionSnapshotLinux::Initialize(
@@ -397,7 +469,7 @@ bool ExceptionSnapshotLinux::Initialize(
       return false;
     }
   } else {
-#if !defined(ARCH_CPU_RISCV64)
+#if !defined(ARCH_CPU_RISCV64) && !defined(ARCH_CPU_LOONGARCH64)
     if (!ReadContext<ContextTraits32>(process_reader, context_address) ||
         !ReadSiginfo<Traits32>(process_reader, siginfo_address)) {
       return false;
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
index f931d33002..4844ef12fe 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
@@ -91,6 +91,8 @@ class ExceptionSnapshotLinux final : public ExceptionSnapshot {
     CPUContextMIPS64 mips64;
 #elif defined(ARCH_CPU_RISCV64)
     CPUContextRISCV64 riscv64;
+#elif defined(ARCH_CPU_LOONGARCH64)
+    CPUContextLOONGARCH64 loongarch64;
 #endif
   } context_union_;
   CPUContext context_;
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
index 16ae7b671f..62dc304de7 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
@@ -297,6 +297,48 @@ void ExpectContext(const CPUContext& actual, const NativeCPUContext& expected) {
             0);
 #undef CPU_ARCH_NAME
 }
+#elif defined(ARCH_CPU_LOONGARCH64)
+using NativeCPUContext = ucontext_t;
+struct TestCoprocessorContext {
+  sctx_info sctx;
+  fpu_context fpu;
+};
+
+void InitializeContext(NativeCPUContext* context) {
+  context->uc_mcontext.__pc = 1;
+  for (size_t reg = 0; reg < std::size(context->uc_mcontext.__gregs); ++reg) {
+    context->uc_mcontext.__gregs[reg] = reg;
+  }
+
+auto test_context = reinterpret_cast<TestCoprocessorContext*>(
+      context->uc_mcontext.__extcontext);
+  test_context->sctx.magic = 0;
+  test_context->sctx.size = 0;;
+
+  for (size_t reg = 0; reg < std::size(test_context->fpu.regs); ++reg) {
+    test_context->fpu.regs[reg] = reg;
+
+  test_context->fpu.fcc = 1;
+  test_context->fpu.fcsr = 2;
+  }
+}
+
+void ExpectContext(const CPUContext& actual, const NativeCPUContext& expected) {
+  EXPECT_EQ(actual.architecture, kCPUArchitectureLOONGARCH64);
+
+  auto test_context = reinterpret_cast< const TestCoprocessorContext*>(
+       expected.uc_mcontext.__extcontext);
+  for (size_t reg = 0; reg < std::size(expected.uc_mcontext.__gregs); ++reg) {
+    EXPECT_EQ(actual.loongarch64->sc_regs[reg], expected.uc_mcontext.__gregs[reg]);
+  }
+
+  EXPECT_EQ(memcmp(&actual.loongarch64->fregs,
+                   &test_context->fpu.regs,
+                   sizeof(actual.loongarch64->fregs)),
+            0);
+  EXPECT_EQ(actual.loongarch64->fcc, test_context->fpu.fcc);
+  EXPECT_EQ(actual.loongarch64->fcsr, test_context->fpu.fcsr);
+}
 
 #elif defined(ARCH_CPU_RISCV64)
 using NativeCPUContext = ucontext_t;
diff --git a/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
index 45713386d9..3afcd51478 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
@@ -129,6 +129,8 @@ void ProcessReaderLinux::Thread::InitializeStack(ProcessReaderLinux* reader) {
                                     : thread_info.thread_context.t32.regs[29];
 #elif defined(ARCH_CPU_RISCV64)
   stack_pointer = thread_info.thread_context.t64.regs[1];
+#elif defined(ARCH_CPU_LOONGARCH64)
+  stack_pointer = thread_info.thread_context.t64.regs[3];
 #else
 #error Port.
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/linux/signal_context.h b/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
index 89e697a08b..e1161a13f8 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
@@ -456,6 +456,44 @@ static_assert(offsetof(UContext<ContextTraits64>, mcontext.fpregs) ==
                   offsetof(ucontext_t, uc_mcontext.__fpregs),
               "context offset mismatch");
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+
+struct MContext64 {
+  uint64_t sc_pc;
+  uint64_t gregs[32];
+  uint32_t sc_flags;
+  uint64_t sc_extcontext[0] __attribute__((__aligned__(16)));
+};
+
+struct SCTXInfo {
+  uint32_t magic;
+  uint32_t size;
+  uint64_t padding;
+};
+
+struct FPUContext {
+  uint64_t regs[32];
+  uint64_t fcc;
+  uint32_t fcsr;
+};
+
+struct ContextTraits64 : public Traits64 {
+  using MContext = MContext64;
+  using SignalThreadContext = ThreadContext::t64_t;
+  using SignalFloatContext = FloatContext::f64_t;
+  using CPUContext = CPUContextLOONGARCH64;
+};
+
+template <typename Traits>
+struct UContext {
+  typename Traits::ULong flags;
+  typename Traits::Address link;
+  SignalStack<Traits> stack;
+  Sigset<Traits> sigmask;
+  char padding[128 - sizeof(sigmask)];
+  typename Traits::MContext mcontext;
+};
+
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
index b32f22d784..631cf9ce3e 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
@@ -208,6 +208,8 @@ CPUArchitecture SystemSnapshotLinux::GetCPUArchitecture() const {
                                     : kCPUArchitectureMIPSEL;
 #elif defined(ARCH_CPU_RISCV64)
   return kCPUArchitectureRISCV64;
+#elif defined(ARCH_CPU_LOONGARCH64)
+  return kCPUArchitectureLOONGARCH64;
 #else
 #error port to your architecture
 #endif
@@ -226,6 +228,9 @@ uint32_t SystemSnapshotLinux::CPURevision() const {
 #elif defined(ARCH_CPU_RISCV64)
   // Not implemented
   return 0;
+#elif defined(ARCH_CPU_LOONGARCH64)
+  // Not implementable on LOONGARCH64
+  return 0;
 #else
 #error port to your architecture
 #endif
@@ -249,6 +254,9 @@ std::string SystemSnapshotLinux::CPUVendor() const {
 #elif defined(ARCH_CPU_RISCV64)
   // Not implemented
   return std::string();
+#elif defined(ARCH_CPU_LOONGARCH64)
+  // Not implementable on LOONGARCH64
+  return std::string();
 #else
 #error port to your architecture
 #endif
@@ -385,6 +393,9 @@ bool SystemSnapshotLinux::NXEnabled() const {
 #elif defined(ARCH_CPU_RISCV64)
   // Not implemented
   return false;
+#elif defined(ARCH_CPU_LOONGARCH64)
+  // Not implementable on LOONGARCH64
+  return false;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc b/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc
index c03cbaae56..cd4a18acf2 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc
@@ -112,6 +112,10 @@ bool WriteTestModule(const base::FilePath& module_path,
   module.ehdr.e_machine = EM_MIPS;
 #elif defined(ARCH_CPU_RISCV64)
   module.ehdr.e_machine = EM_RISCV;
+#elif defined(ARCH_CPU_LOONGARCH64)
+  module.ehdr.e_machine = EM_LOONGARCH;
+  module.ehdr.e_flags |= EF_LARCH_ABI_DOUBLE_FLOAT;
+  module.ehdr.e_flags |= EF_LARCH_OBJABI_V1;
 #endif
 
 #if defined(ARCH_CPU_RISCV64)
diff --git a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
index 85882e8ee4..c2cf1a9f3d 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
@@ -196,6 +196,12 @@ bool ThreadSnapshotLinux::Initialize(
   InitializeCPUContextRISCV64(thread.thread_info.thread_context.t64,
                               thread.thread_info.float_context.f64,
                               context_.riscv64);
+#elif defined(ARCH_CPU_LOONGARCH64)
+  context_.architecture = kCPUArchitectureLOONGARCH64;
+  context_.loongarch64 = &context_union_.loongarch64;
+  InitializeCPUContextLOONGARCH64(thread.thread_info.thread_context.t64,
+				  thread.thread_info.float_context.f64,
+				  context_.loongarch64);
 #else
 #error Port.
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
index 5795bfb985..bdfd237cb5 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
@@ -76,6 +76,8 @@ class ThreadSnapshotLinux final : public ThreadSnapshot {
     CPUContextMIPS64 mips64;
 #elif defined(ARCH_CPU_RISCV64)
     CPUContextRISCV64 riscv64;
+#elif defined(ARCH_CPU_LOONGARCH64)
+    CPUContextLOONGARCH64 loongarch64;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc b/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc
index ec02dff126..2e6e846f77 100644
--- a/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc
+++ b/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc
@@ -293,6 +293,28 @@ bool MinidumpContextConverter::Initialize(
     memcpy(&context_.riscv64->fpregs, &src->fpregs, sizeof(src->fpregs));
 
     context_.riscv64->fcsr = src->fcsr;
+  } else if (context_.architecture ==
+             CPUArchitecture::kCPUArchitectureLOONGARCH64) {
+    context_memory_.resize(sizeof(CPUContextLOONGARCH64));
+    context_.loongarch64 =
+        reinterpret_cast<CPUContextLOONGARCH64*>(context_memory_.data());
+    const MinidumpContextLOONGARCH64* src =
+        reinterpret_cast<const MinidumpContextLOONGARCH64*>(minidump_context.data());
+    if (minidump_context.size() < sizeof(MinidumpContextLOONGARCH64)) {
+      return false;
+    }
+
+    if (!(src->context_flags & kMinidumpContextLOONGARCH64)) {
+      return false;
+    }
+
+    for (size_t i = 0; i < std::size(src->sc_regs); i++) {
+      context_.loongarch64->sc_regs[i] = src->sc_regs[i];
+    }
+
+    context_.loongarch64->sc_pc = src->sc_pc;
+    context_.loongarch64->fcsr = src->fcsr;
+    context_.loongarch64->fcc = src->fcc;
   } else {
     // Architecture is listed as "unknown".
     DLOG(ERROR) << "Unknown architecture";
diff --git a/third_party/crashpad/crashpad/snapshot/minidump/system_snapshot_minidump.cc b/third_party/crashpad/crashpad/snapshot/minidump/system_snapshot_minidump.cc
index 58bd7b3647..0e8a3a4659 100644
--- a/third_party/crashpad/crashpad/snapshot/minidump/system_snapshot_minidump.cc
+++ b/third_party/crashpad/crashpad/snapshot/minidump/system_snapshot_minidump.cc
@@ -70,6 +70,8 @@ CPUArchitecture SystemSnapshotMinidump::GetCPUArchitecture() const {
     // No word on how MIPS64 is signalled
     case kMinidumpCPUArchitectureRISCV64Breakpad:
       return kCPUArchitectureRISCV64;
+    case kMinidumpCPUArchitectureLOONGARCH64:
+      return kCPUArchitectureLOONGARCH64;
 
     default:
       return CPUArchitecture::kCPUArchitectureUnknown;
diff --git a/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.cc b/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.cc
index 9982294663..5cd4d85d44 100644
--- a/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.cc
+++ b/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.cc
@@ -317,5 +317,25 @@ void InitializeCPUContextRISCV64(CPUContext* context, uint32_t seed) {
   riscv64->fcsr = value++;
 }
 
+void InitializeCPUContextLOONGARCH64(CPUContext* context, uint32_t seed) {
+  context->architecture = kCPUArchitectureLOONGARCH64;
+  CPUContextLOONGARCH64* loongarch64 = context->loongarch64;
+
+  if (seed == 0) {
+    memset(loongarch64, 0, sizeof(*loongarch64));
+    return;
+  }
+
+  uint64_t value = seed;
+
+  for (size_t index = 0; index < std::size(loongarch64->fregs); ++index) {
+    loongarch64->fregs[index] = value++;
+  }
+
+  loongarch64->sc_pc = value++;
+  loongarch64->fcsr = value++;
+  loongarch64->fcc = value++;
+}
+
 }  // namespace test
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.h b/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.h
index 053dec28bc..ce9184c88c 100644
--- a/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.h
+++ b/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.h
@@ -64,6 +64,7 @@ void InitializeCPUContextARM64(CPUContext* context, uint32_t seed);
 void InitializeCPUContextMIPS(CPUContext* context, uint32_t seed);
 void InitializeCPUContextMIPS64(CPUContext* context, uint32_t seed);
 void InitializeCPUContextRISCV64(CPUContext* context, uint32_t seed);
+void InitializeCPUContextLOONGARCH64(CPUContext* context, uint32_t seed);
 //! \}
 
 }  // namespace test
diff --git a/third_party/crashpad/crashpad/test/linux/get_tls.cc b/third_party/crashpad/crashpad/test/linux/get_tls.cc
index 405976eaa9..f3c9f83cae 100644
--- a/third_party/crashpad/crashpad/test/linux/get_tls.cc
+++ b/third_party/crashpad/crashpad/test/linux/get_tls.cc
@@ -51,6 +51,9 @@ LinuxVMAddress GetTLS() {
       : "$3");
 #elif defined(ARCH_CPU_RISCV64)
   asm("mv %0, tp" : "=r"(tls));
+#elif defined(ARCH_CPU_LOONGARCH64)
+  asm("move    %0,$tp\n\t"
+      : "=r"(tls) ::);
 #else
 #error Port.
 #endif  // ARCH_CPU_ARMEL
diff --git a/third_party/crashpad/crashpad/test/multiprocess_posix.cc b/third_party/crashpad/crashpad/test/multiprocess_posix.cc
index eb7cf9cd15..b1a27c93ff 100644
--- a/third_party/crashpad/crashpad/test/multiprocess_posix.cc
+++ b/third_party/crashpad/crashpad/test/multiprocess_posix.cc
@@ -162,7 +162,8 @@ void Multiprocess::SetExpectedChildTermination(TerminationReason reason,
 }
 
 void Multiprocess::SetExpectedChildTerminationBuiltinTrap() {
-#if defined(ARCH_CPU_ARM64) || defined(ARCH_CPU_MIPS_FAMILY)
+#if defined(ARCH_CPU_ARM64) || defined(ARCH_CPU_MIPS_FAMILY) ||\
+    defined (ARCH_CPU_LOONGARCH64)
   SetExpectedChildTermination(kTerminationSignal, SIGTRAP);
 #else
   SetExpectedChildTermination(kTerminationSignal, SIGILL);
diff --git a/third_party/crashpad/crashpad/util/linux/ptracer.cc b/third_party/crashpad/crashpad/util/linux/ptracer.cc
index a985cb1d1f..8f22b76cce 100644
--- a/third_party/crashpad/crashpad/util/linux/ptracer.cc
+++ b/third_party/crashpad/crashpad/util/linux/ptracer.cc
@@ -430,6 +430,49 @@ bool GetThreadArea64(pid_t tid,
   return true;
 }
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+
+bool GetFloatingPointRegisters32(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) {
+  return false;
+}
+
+bool GetFloatingPointRegisters64(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) {
+  iovec iov;
+  iov.iov_base = context;
+  iov.iov_len = sizeof(*context);
+  if (ptrace(PTRACE_GETREGSET, tid, reinterpret_cast<void*>(NT_PRFPREG), &iov) != 0) {
+    PLOG_IF(ERROR, can_log) << "ptrace";
+    return false;
+  }
+  if (iov.iov_len != sizeof(context->f64)) {
+    LOG_IF(ERROR, can_log) << "Unexpected registers size " << iov.iov_len
+                           << " != " << sizeof(context->f64);
+    return false;
+  }
+
+  return true;
+}
+
+bool GetThreadArea32(pid_t tid,
+                     const ThreadContext& context,
+                     LinuxVMAddress* address,
+                     bool can_log) {
+  return false;
+}
+
+bool GetThreadArea64(pid_t tid,
+                     const ThreadContext& context,
+                     LinuxVMAddress* address,
+                     bool can_log) {
+  // Thread pointer register
+  *address = context.t64.regs[2];
+  return true;
+}
+
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/util/linux/thread_info.h b/third_party/crashpad/crashpad/util/linux/thread_info.h
index 808b35a3af..7a3da241c6 100644
--- a/third_party/crashpad/crashpad/util/linux/thread_info.h
+++ b/third_party/crashpad/crashpad/util/linux/thread_info.h
@@ -87,6 +87,8 @@ union ThreadContext {
     uint32_t padding1_;
 #elif defined(ARCH_CPU_RISCV64)
     // 32 bit RISC-V not supported
+#elif defined(ARCH_CPU_LOONGARCH64)
+    // 32 bit LOONGARCH not supported
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -144,6 +146,11 @@ union ThreadContext {
     // Reflects user_regs_struct in asm/ptrace.h.
     uint64_t pc;
     uint64_t regs[31];
+#elif defined(ARCH_CPU_LOONGARCH64)
+    // Reflects user_regs_struct in sys/user.h.
+    uint64_t regs[32];
+    uint64_t csr_era;
+    uint64_t _pad[12];
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -154,13 +161,13 @@ union ThreadContext {
   using NativeThreadContext = user_regs_struct;
 #elif defined(ARCH_CPU_ARMEL)
   using NativeThreadContext = user_regs;
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY)  || defined (ARCH_CPU_LOONGARCH64)
 // No appropriate NativeThreadsContext type available for MIPS
 #else
 #error Port.
-#endif  // ARCH_CPU_X86_FAMILY || ARCH_CPU_ARM64 || ARCH_CPU_RISCV64
+#endif  // ARCH_CPU_X86_FAMILY || ARCH_CPU_ARM64 || ARCH_CPU_RISCV64 || ARCH_CPU_LOONGARCH64
 
-#if !defined(ARCH_CPU_MIPS_FAMILY)
+#if !defined(ARCH_CPU_MIPS_FAMILY) && !defined(ARCH_CPU_LOONGARCH64)
 #if defined(ARCH_CPU_32_BITS)
   static_assert(sizeof(t32_t) == sizeof(NativeThreadContext), "Size mismatch");
 #else  // ARCH_CPU_64_BITS
@@ -233,6 +240,8 @@ union FloatContext {
     uint32_t fpu_id;
 #elif defined(ARCH_CPU_RISCV64)
     // 32 bit RISC-V not supported
+#elif defined(ARCH_CPU_LOONGARCH64)
+    // 32 bit LOONGARCH not supported
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -271,6 +280,10 @@ union FloatContext {
     // Reflects __riscv_d_ext_state in asm/ptrace.h
     uint64_t fpregs[32];
     uint64_t fcsr;
+#elif defined(ARCH_CPU_LOONGARCH64)
+    uint64_t fregs[32];
+    uint32_t fcsr;
+    uint64_t fcc;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -298,7 +311,7 @@ union FloatContext {
 #endif
 #elif defined(ARCH_CPU_ARM64)
   static_assert(sizeof(f64) == sizeof(user_fpsimd_struct), "Size mismatch");
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined (ARCH_CPU_LOONGARCH64)
 // No appropriate floating point context native type for available MIPS.
 #elif defined(ARCH_CPU_RISCV64)
   static_assert(sizeof(f64) == sizeof(__riscv_d_ext_state), "Size mismatch");
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context.h b/third_party/crashpad/crashpad/util/misc/capture_context.h
index ac7707b48c..f975155bad 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context.h
+++ b/third_party/crashpad/crashpad/util/misc/capture_context.h
@@ -70,6 +70,7 @@ using NativeCPUContext = ucontext_t;
 //!     Linux               | ARM/ARM64    | `r0`/`x0`
 //!     Linux               | MIPS/MIPS64  | `$a0`
 //!     Linux               | RISCV64      | `a0`
+//!     Linux               | LOONGARCH64  | `$a0`
 //!
 //!     Additionally, the value `LR` on ARM/ARM64 will be the return address of
 //!     this function.
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context_linux.S b/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
index cfad85738e..045f85d925 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
+++ b/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
@@ -30,7 +30,7 @@
   .globl CAPTURECONTEXT_SYMBOL2
 #if defined(__i386__) || defined(__x86_64__)
   .balign 16, 0x90
-#elif defined(__arm__) || defined(__aarch64__)
+#elif defined(__arm__) || defined(__aarch64__) || defined(__loongarch_lp64)
   .balign 4, 0x0
   .type CAPTURECONTEXT_SYMBOL, %function
   .type CAPTURECONTEXT_SYMBOL2, %function
@@ -510,4 +510,84 @@ CAPTURECONTEXT_SYMBOL2:
 
   ret
 
+#elif defined(__loongarch_lp64)
+
+#define MCONTEXT_GREG_SIZE 8
+#define MCONTEXT_FPREG_SIZE 8
+#define MCONTEXT_PC_OFFSET 64
+#define MCONTEXT_GREGS_OFFSET 72
+#define MCONTEXT_FPREGS_OFFSET 352
+
+#define STORE_GPR(X) st.d $r##X, $a0, MCONTEXT_GREGS_OFFSET + X * MCONTEXT_GREG_SIZE
+#define STORE_FPR(X) fst.d $f##X, $a0, MCONTEXT_FPREGS_OFFSET + X * MCONTEXT_FPREG_SIZE
+#define STORE_PC st.d $ra, $a0, MCONTEXT_PC_OFFSET
+
+  STORE_PC
+  STORE_GPR(0)
+  STORE_GPR(1)
+  STORE_GPR(2)
+  STORE_GPR(3)
+  STORE_GPR(4)
+  STORE_GPR(5)
+  STORE_GPR(6)
+  STORE_GPR(7)
+  STORE_GPR(8)
+  STORE_GPR(9)
+  STORE_GPR(10)
+  STORE_GPR(11)
+  STORE_GPR(12)
+  STORE_GPR(13)
+  STORE_GPR(14)
+  STORE_GPR(15)
+  STORE_GPR(16)
+  STORE_GPR(17)
+  STORE_GPR(18)
+  STORE_GPR(19)
+  STORE_GPR(20)
+  STORE_GPR(21)
+  STORE_GPR(22)
+  STORE_GPR(23)
+  STORE_GPR(24)
+  STORE_GPR(25)
+  STORE_GPR(26)
+  STORE_GPR(27)
+  STORE_GPR(28)
+  STORE_GPR(29)
+  STORE_GPR(30)
+  STORE_GPR(31)
+  STORE_FPR(0)
+  STORE_FPR(1)
+  STORE_FPR(2)
+  STORE_FPR(3)
+  STORE_FPR(4)
+  STORE_FPR(5)
+  STORE_FPR(6)
+  STORE_FPR(7)
+  STORE_FPR(8)
+  STORE_FPR(9)
+  STORE_FPR(10)
+  STORE_FPR(11)
+  STORE_FPR(12)
+  STORE_FPR(13)
+  STORE_FPR(14)
+  STORE_FPR(15)
+  STORE_FPR(16)
+  STORE_FPR(17)
+  STORE_FPR(18)
+  STORE_FPR(19)
+  STORE_FPR(20)
+  STORE_FPR(21)
+  STORE_FPR(22)
+  STORE_FPR(23)
+  STORE_FPR(24)
+  STORE_FPR(25)
+  STORE_FPR(26)
+  STORE_FPR(27)
+  STORE_FPR(28)
+  STORE_FPR(29)
+  STORE_FPR(30)
+  STORE_FPR(31)
+
+  jirl $zero, $ra, 0
+
 #endif  // __i386__
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context_test.cc b/third_party/crashpad/crashpad/util/misc/capture_context_test.cc
index 2cd92c841a..4b95f86ddc 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context_test.cc
+++ b/third_party/crashpad/crashpad/util/misc/capture_context_test.cc
@@ -48,7 +48,7 @@ void TestCaptureContext() {
   uintptr_t pc = ProgramCounterFromContext(context_1);
 
 #if !defined(ADDRESS_SANITIZER) && !defined(ARCH_CPU_MIPS_FAMILY) && \
-    !defined(MEMORY_SANITIZER)
+    !defined(MEMORY_SANITIZER) && !defined(ARCH_CPU_LOONGARCH64)
   // Sanitizers can cause enough code bloat that the “nearby” check would
   // likely fail.
   const uintptr_t kReferencePC =
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc b/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
index 55820b9ee7..8f8496cf6c 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
+++ b/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
@@ -38,6 +38,8 @@ void SanityCheckContext(const NativeCPUContext& context) {
 #elif defined(ARCH_CPU_RISCV64)
   EXPECT_EQ(context.uc_mcontext.__gregs[10],
             FromPointerCast<uintptr_t>(&context));
+#elif defined(ARCH_CPU_LOONGARCH64)
+  EXPECT_EQ(context.uc_mcontext.__gregs[4], FromPointerCast<uintptr_t>(&context));
 #endif
 }
 
@@ -54,6 +56,8 @@ uintptr_t ProgramCounterFromContext(const NativeCPUContext& context) {
   return context.uc_mcontext.pc;
 #elif defined(ARCH_CPU_RISCV64)
   return context.uc_mcontext.__gregs[0];
+#elif defined(ARCH_CPU_LOONGARCH64)
+  return context.uc_mcontext.__pc;
 #endif
 }
 
@@ -70,6 +74,8 @@ uintptr_t StackPointerFromContext(const NativeCPUContext& context) {
   return context.uc_mcontext.gregs[29];
 #elif defined(ARCH_CPU_RISCV64)
   return context.uc_mcontext.__gregs[2];
+#elif defined(ARCH_CPU_LOONGARCH64)
+  return context.uc_mcontext.__gregs[3];
 #endif
 }
 
diff --git a/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc b/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
index df63a77296..a897f865c8 100644
--- a/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
+++ b/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
@@ -239,6 +239,8 @@ std::string UserAgent() {
 #endif
 #elif defined (ARCH_CPU_RISCV64)
     static constexpr char arch[] = "riscv64";
+#elif defined(ARCH_CPU_LOONGARCH64)
+    static constexpr char arch[] = "loongarch64";
 #else
 #error Port
 #endif
-- 
2.31.1

