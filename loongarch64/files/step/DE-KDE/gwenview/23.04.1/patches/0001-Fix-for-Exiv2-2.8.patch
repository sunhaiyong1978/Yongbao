From fcf48d8a65ba7f1f6b2f126ecec1712d6902ebab Mon Sep 17 00:00:00 2001
From: Sun Haiyong <sunhaiyong@zdbr.net>
Date: Sun, 28 May 2023 15:21:07 +0000
Subject: [PATCH] Fix for Exiv2 2.8

---
 lib/jpegcontent.cpp | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/lib/jpegcontent.cpp b/lib/jpegcontent.cpp
index 284fb6e..2059edc 100644
--- a/lib/jpegcontent.cpp
+++ b/lib/jpegcontent.cpp
@@ -301,7 +301,7 @@ Orientation JpegContent::orientation() const
     if (it == d->mExifData.end() || it->count() == 0 || it->typeId() != Exiv2::unsignedShort) {
         return NOT_AVAILABLE;
     }
-    return Orientation(it->toLong());
+    return Orientation(it->toUint32());
 }
 
 int JpegContent::dotsPerMeterX() const
@@ -321,7 +321,7 @@ int JpegContent::dotsPerMeter(const QString &keyName) const
     if (it == d->mExifData.end()) {
         return 0;
     }
-    int res = it->toLong();
+    int res = it->toUint32();
     QString keyVal = QStringLiteral("Exif.Image.") + keyName;
     Exiv2::ExifKey keyResolution(keyVal.toLocal8Bit().data());
     it = d->mExifData.findKey(keyResolution);
@@ -337,9 +337,9 @@ int JpegContent::dotsPerMeter(const QString &keyName) const
     const float INCHESPERMETER = (100. / 2.54);
     switch (res) {
     case 3: // dots per cm
-        return int(it->toLong() * 100);
+        return int(it->toUint32() * 100);
     default: // dots per inch
-        return int(it->toLong() * INCHESPERMETER);
+        return int(it->toUint32() * INCHESPERMETER);
     }
 
     return 0;
@@ -568,15 +568,15 @@ QImage JpegContent::thumbnail() const
         auto it = d->mExifData.findKey(Exiv2::ExifKey("Exif.Canon.ThumbnailImageValidArea"));
         // ensure ThumbnailImageValidArea actually specifies a rectangle, i.e. there must be 4 coordinates
         if (it != d->mExifData.end() && it->count() == 4) {
-            QRect validArea(QPoint(it->toLong(0), it->toLong(2)), QPoint(it->toLong(1), it->toLong(3)));
+            QRect validArea(QPoint(it->toUint32(0), it->toUint32(2)), QPoint(it->toUint32(1), it->toUint32(3)));
             image = image.copy(validArea);
         } else {
             // Unfortunately, Sony does not provide an exif tag that specifies the valid area of the
             // embedded thumbnail. Need to derive it from the size of the preview image instead.
             it = d->mExifData.findKey(Exiv2::ExifKey("Exif.Sony1.PreviewImageSize"));
             if (it != d->mExifData.end() && it->count() == 2) {
-                const long prevHeight = it->toLong(0);
-                const long prevWidth = it->toLong(1);
+                const long prevHeight = it->toUint32(0);
+                const long prevWidth = it->toUint32(1);
 
                 if (image.width() > 0 && prevWidth > 0) {
                     const double scale = prevWidth / image.width();
-- 
2.31.1

